# scfifo
```verilog
`timescale  1 ns/1 ps

module scfifo_tb ();

reg                     clk = 0;
always
    #(1s/100_000_000/2) clk = ~clk;

logic                       fifo_wrreq = 0;
logic   [07:00]             fifo_wrdata = 0;


task wr_data();
    #1us;
    fifo_wrreq = 1;
    repeat(1000)
    begin
        @(posedge clk);
        fifo_wrdata = $urandom_range(0, 255);
    end
    fifo_wrreq = 0;
endtask


initial
begin
    wr_data();
end

	wire  sub_wire0;
	wire  sub_wire1;
	wire [7:0] sub_wire2;
	wire [7:0] sub_wire3;
	wire  empty = sub_wire0;
	wire  full = sub_wire1;
	wire [7:0] q = sub_wire2[7:0];
	wire [7:0] usedw = sub_wire3[7:0];

scfifo	scfifoEx01
(
    .clock           (    clk            ),

    .wrreq           (    fifo_wrreq     ),
    .data            (    fifo_wrdata    ),
    .full            (                   ),
    .almost_full     (                   ),

    .rdreq           (    1'b0           ),
    .q               (                   ),
    .empty           (                   ),
    .almost_empty    (                   ),

    .usedw           (                   ),
    .aclr            (                   ),
    .eccstatus       (                   ),
    .sclr            (                   )
);
defparam
    scfifoEx01.add_ram_output_register = "OFF",                 // ON: 性能优先
    scfifoEx01.intended_device_family = "Cyclone IV GX",
    scfifoEx01.lpm_hint = "RAM_BLOCK_TYPE=M9K",
    scfifoEx01.lpm_numwords = 256,                             // FIFO深度
    scfifoEx01.lpm_showahead = "OFF",
    scfifoEx01.lpm_type = "scfifo",
    scfifoEx01.lpm_width = 8,                                   // 指定FIFO的数据端口宽度
    scfifoEx01.lpm_widthu = 8,                                 // FIFO深度所需要的位宽
    scfifoEx01.overflow_checking = "ON",
    scfifoEx01.underflow_checking = "ON",
    scfifoEx01.use_eab = "ON";
endmodule
```

# 2-port ram
## 一端口写，一端口读
```verilog
`timescale  1 ns/1 ps

module ram2port_tb ();

reg                     clk = 0;
always
    #(1s/100_000_000/2) clk = ~clk;

logic                       ram_wren = 0;
logic   [07:00]             ram_wrdata = 0;
logic   [09:00]             ram_wraddr = 0;

task wr_data();
    #1us;
    ram_wren = 1;
    for(int i = 0; i < 2000; i = i + 1 )
    begin
        @(posedge clk);
        ram_wraddr = i;
        ram_wrdata = i;
    end
    ram_wren = 0;
endtask

initial
begin
    wr_data();
end

altsyncram	ramEx01
(
    .clock0            (    clk           ),
    .wren_a            (    ram_wren      ),
    .address_a         (    ram_wraddr    ),
    .data_a            (    ram_wrdata    ),

    .rden_b            (    0             ),
    .address_b         (                  ),
    .q_b               (                  ),  // sub_wire0
    .aclr0             (    1'b0          ),
    .aclr1             (    1'b0          ),
    .addressstall_a    (    1'b0          ),
    .addressstall_b    (    1'b0          ),
    .byteena_a         (    1'b1          ),
    .byteena_b         (    1'b1          ),
    .clock1            (    1'b1          ),
    .clocken0          (    1'b1          ),
    .clocken1          (    1'b1          ),
    .clocken2          (    1'b1          ),
    .clocken3          (    1'b1          ),
    .data_b            (    {8{1'b1}}     ),
    .eccstatus         (                  ),
    .q_a               (                  ),
    .rden_a            (    1'b1          ),
    .wren_b            (    1'b0          )
);
defparam
    ramEx01.address_aclr_b = "NONE",
    ramEx01.address_reg_b = "CLOCK0",
    ramEx01.clock_enable_input_a = "BYPASS",
    ramEx01.clock_enable_input_b = "BYPASS",
    ramEx01.clock_enable_output_b = "BYPASS",
    ramEx01.intended_device_family = "Cyclone IV GX",
    ramEx01.lpm_type = "altsyncram",
    ramEx01.numwords_a = 1024,                             // RAM 深度
    ramEx01.numwords_b = 1024,
    ramEx01.operation_mode = "DUAL_PORT",
    ramEx01.outdata_aclr_b = "NONE",
    ramEx01.outdata_reg_b = "CLOCK0",
    ramEx01.power_up_uninitialized = "FALSE",
    ramEx01.rdcontrol_reg_b = "CLOCK0",
    ramEx01.read_during_write_mode_mixed_ports = "DONT_CARE",
    ramEx01.widthad_a = 10,
    ramEx01.widthad_b = 10,
    ramEx01.width_a = 8,                                   // 每个单位数据宽度 data_b与此相同
    ramEx01.width_b = 8,
    ramEx01.width_byteena_a = 1;

endmodule
```

# 乘法器
```verilog
lpm_mult	mult_Ex01 
(
    .clock     (    clk          ),
    .dataa     (    dataa        ),
    .datab     (    datab        ),
    .result    (                 ),
    .aclr      (    1'b0         ),
    .clken     (    1'b1         ),
    .sclr      (    1'b0         ),
    .sum       (    1'b0         )
);
defparam
mult_Ex01.lpm_hint = "MAXIMIZE_SPEED=9",
mult_Ex01.lpm_pipeline = 1,
mult_Ex01.lpm_representation = "UNSIGNED",
mult_Ex01.lpm_type = "LPM_MULT",
mult_Ex01.lpm_widtha = 32,
mult_Ex01.lpm_widthb = 12,
mult_Ex01.lpm_widthp = 44;
```

# 除法器
```verilog
lpm_divide	div_Ex01 
(
    .clock       (    clk          ),
    .denom       (    denom        ),   // 分母
    .numer       (    numer        ),   // 分子
    .quotient    (                 ),   // 商
    .remain      (                 ),   // 余数
    .aclr        (    1'b0         ),
    .clken       (    1'b1         )
);
defparam
    div_Ex01.lpm_drepresentation = "UNSIGNED",
    div_Ex01.lpm_hint = "LPM_REMAINDERPOSITIVE=TRUE",
    div_Ex01.lpm_nrepresentation = "UNSIGNED",
    div_Ex01.lpm_pipeline = 8,
    div_Ex01.lpm_type = "LPM_DIVIDE",
    div_Ex01.lpm_widthd = 6,
    div_Ex01.lpm_widthn = 12;
```