# 9.1 概述
链路层发送和接收帧，根据传输层的控制信号发送原语，并从物理层接收被转换成控制信号的原语到传输层。链接层不需要识别帧的内容。主机和设备链路层状态机是相似的，但是，当主机和设备请求传输所有权时，设备被赋予优先权。


## 9.1.1 帧传输
1. 与对等链路层协商传输帧，解决主机和设备请求传输时的仲裁冲突
2. 在传输层数据（即SOFP，CRC，EOFP等）周围插入帧信息。
3. 接收来自传输层的双字形式的数据
4. 计算传输层数据上的CRC。
5. 传输帧。
6. 响应来自FIFO或对等链路层的请求，提供帧流控制
7. 向传输层报告传输成功或者链路层/物理层错误信息
8. 执行8b / 10b编码

## 9.1.2 帧接收
当从Phy层接收数据时，链路层提供以下服务：
1. 确认对等链路层准备好接收帧。
2. 接收来自Phy层的编码字符形式的数据。
3. 接收来自Phy层的编码字符形式的数据。
4. 去除框架周围的信息（即SOFP，CRC，EOFP）。
5. 计算接收到的Dword上的CRC。
6. 响应来自FIFO或对等链路层的请求，提供帧流控制。
7. 将计算的CRC与收到的CRC进行比较。
8. 向传输层和对等链路报告良好的接收或链路/物理层错误。
9. 对从对等链路层接收到的数据进行解扰。

# 9.2 编码方法
通过串行ATA传输的信息应该每次编码一个字节（8位），连同数据或控制字符指示符一起编码为10位编码字符，然后逐位串行发送。 通过串行ATA收到的信息一次收集十位，组合成编码字符，并解码成正确的数据字符和控制字符。 8b / 10b代码允许对8位数据的所有256个组合进行编码。 串行ATA使用控制字符集的一个子集。

## 9.2.1 符号和惯例
串行ATA使用字母符号来描述数据位和控制变量。 这些符号之间的翻译过程的描述如下。 本节还介绍了用于区分数据字符和控制字符的约定。 最后给出了数据字符和控制字符的翻译实例

未编码的数据字节由八位A，B，C，D，E，F，G，H和控制变量Z组成。编码过程产生一个10位字符a，b，c，d，e，I，F，G，H，J。 1bit是二进制0或者1。 控制变量Z具有值D或K。当与字节相关联的控制变量具有值D时，该字节被称为数据字符。 当与字节相关的控制变量具有值K时，该字节被称为控制字符

如果一个数据字节没有附带一个特定的控制变量值，那么假定控制变量Z = D，数据字节应该被编码为一个数据字符。

下面的表53说明了编码方案中一个字节中编号的未编码比特，控制变量和字母标记比特之间的关联：
表53：位指定
字节符号   | 7 |6| 5| 4| 3| 2| 1| 0| 变量控制
---- | --- |---|---|---|---|---|---|---|---|---
未编码位符号 | H| G| F| E| D| C| B| A| Z

每个字符都有一个名称Zxx.y，其中Z是控制变量的值（D表示数据字符，K表示控制字符），xx是由E，D，C位组成的二进制数的十进制值 ，B和A，y是由H，G和F位组成的二进制数的十进制值。

下面的图190，显示了各种表示之间的关系。

![](https://github.com/kdurant/sata_controller/blob/master/doc/pic/ch9/Figure190.png?raw=true)

下面的表54显示了控制字节和数据字节从字节符号到字符符号的转换。 所选择的例子具有特殊意义，并且在从数据符号到8b / 10b代码值的转换中也被使用。
![](https://github.com/kdurant/sata_controller/blob/master/doc/pic/ch9/Table54.png?raw=true)

## 9.2.2 字符码
串行ATA使用的编码方案将未编码的数据和控制字节转换为字符。 然后，编码的字符由Phy层通过串行线路传输，从Phy层接收并解码为相应的字节和控制值。

串行ATA使用Widmer和Franaszek描述的8b / 10b编码方法的子集（参见参考文献）。 串行ATA代码使用全部256个数据字节编码，而仅使用两个`控制代码`。 任何未使用的代码的接收是一类被称为违反代码的接收错误。

### 9.2.2.1 代码构建
8b / 10b编码过程分为两个阶段。 第一阶段使用5B / 6B编码器将未编码输入字节的前五位编码成六位子块。 该阶段的输入包括当前运行差异值。 第二阶段使用3B / 4B编码器将数据字节的其余三位和由5B / 6B编码器修改的运行差异编码为四位值。

在后面的推导中，假定控制变量（Z）具有D的值，因此是隐式输入。

### 9.2.2.2 运行不一致的概念

### 9.2.2.3 数据编码
### 9.2.2.4 编码示例
### 9.2.2.5 8b/10b可用的编码字符
#### 9.2.2.5.1 数据字符


# 9.3 传输总览
串行信息是8b / 10b编码字符序列。 沟通的最小单位是Dword。 每个双字的内容被分组以提供底层控制信息或在主机和连接的设备之间传输信息。

这两种类型的结构是原语和帧

原语由单个双字组成，是主机和设备之间可以交换的最简单的信息单元。 当一个图元的字节被编码时，结果图案很难被误解为任何其他的图元或随机图案。 原语主要用于传达实时状态信息，控制信息传输和协调主机/设备通信。 原语中的所有字节都是常量，第一个字节总是一个特殊字符。 由于所有字节都是常量，因此不能使用原语传递可变信息。 后面几节将介绍串行ATA使用的原语的确切内容。

CRC被定义为紧接在EOFP之前的最后一个非原始Dword。

在SOFP和EOFP原语之间允许一定数量的流量控制基元（HOLDP或HOLDAP，或一个CONTP流维持HOLDP或HOLDAP状态）以节制数据流以达到速度匹配的目的。


串行线路上的信息是8b/10b字符序列。最小的通信单位是Dword。对每个DWord的内容进行分组，以提供低级控制信息或在主机和附加设备之间传输信息。

这两种结构是原语和框架。

原语由单个DWord组成，是主机和设备之间可以交换的最简单的信息单元。当原语的字节被编码时，产生的模式很难被误解为其他原语或随机模式。原语主要用于传递实时状态信息，控制信息传输，协调主机/设备通信。基元中的所有字节都是常量，第一个字节总是一个特殊的字符。因为所有的字节都是常量，所以不能使用原语来传递变量信息。后面的部分描述SerialATA使用的原语的确切内容。

一帧数据由多个Dword组成，并且总是以`SOFp`开头，然后是名为帧信息结构(FIS)的用户有效负载(Frame Information Structure，FIS)、CRC，最后是`EOFp`。CRC被定义为紧接`EOFp`之前的最后一个非原始DWord。允许一些流控制原语(HOLDp或HOLDAp，或支持HOLDp或HOLDAp状态的CONTp流)在`SOFp`和`EOFp`原语之间为速度匹配目的节流数据流。

![192](https://github.com/kdurant/note/blob/master/res/sata/ch09/Figure192.png?raw=true)

# 9.4 原语
## 9.4.1 概述
原语是用于控制和提供串行线状态的Dword实体。

原语总是以控制字符开始; 所有的原语使用`K28.3`控制字符来表示除了以`K28.5`控制字符开始的`ALIGNp`之外的原语的开始。因此`ALIGNp`代表了包含逗号字符的唯一原语。在控制字符之后，三个附加字符被编码以完成双字。
表62是组成每个基元的字符组合的概要。

Primitive   | Name | Description
:---------- |:--------|:------------------------------------------------------------------
ALIGNp      | Phy layer control     |收到一个ALIGNp后，Phy层根据需要重新调整内部操作，以正确执行其功能。 这个原语总是被成对发送。没有什么条件下发送奇数个ALIGNp原语（除了重新定时的环回）
CONTp       |
DMATp       |
EOFp        |
HOLDp       |
HOLDAp      |
PMACKp      |
PMNAKp      |
PMREQ_Pp    |
PMREQ_Sp    |
R_ERPp      |
R_IPp       |
R_OKp       |
R_RDYp      |
SOFp        |
WTRMp       |
X_RDYp      |

### 9.4.1.1 原语不均等性
原语可能以正不均等性和负不均等性开始，并且以正不均等性和负不均等性结束。正常的8b/10b不均等性规则同样适用于原语。

ALIGNp选择中性，以便它可以被插入到数据流中而不影响先前编码字符的不均等性。 ALIGNp结尾处的不均等性与ALIGNp之前传输的最后一个字符的结尾不均等性相同。

### 9.4.1.2 原语握手
一些原语是响应于其他原语的接收来发送的，以确认接收。例如，HOLDAp是响应于HOLDp原语的接收而传输的，而R_OKP或R_ERRp是响应于WTRMp传输的。由于电缆两端之间的时钟域不同，响应原语的数量可能与它们响应的原语数不匹配。例如，一个设备可能发送五个HOLDp原语，但接收六个HOLDAp原语作为响应。这些原语的发送器和接收器都不需要计数原语的数量，也不需要匹配发送和接收的数量。在一些边界情况下，可以发送零数量的响应原语，如HOLDAp。

## 9.4.3 原语编码
Table63 - 原语编码
原语名     | Byte3     | Byte2     | Byte1     | Byte0
:---------:|:---------:|:---------:|:---------:|:--------:
ALIGNp      |D27.3      |D10.2      |D10.2      |`K28.5`
CONTp       |D25.4      |D25.4      |D10.5      |K28.3
DMATp       |D22.1      |D22.1      |D21.5      |K28.3
EOFp        |D21.6      |D21.6      |D21.5      |K28.3
HOLDp       |D21.6      |D21.6      |D10.5      |K28.3
HOLDAp      |D21.4      |D21.4      |D10.5      |K28.3
PMACKp      |D21.4      |D21.4      |D21.4      |K28.3
PMNAKp      |D21.7      |D21.7      |D21.4      |K28.3
PMREQ_Pp    |D23.0      |D23.0      |D21.5      |K28.3
PMREQ_Sp    |D21.3      |D21.3      |D21.4      |K28.3
R_ERRp      |D22.2      |D22.2      |D21.5      |K28.3
R_IPp       |D21.2      |D21.2      |D21.5      |K28.3
R_OKp       |D21.1      |D21.1      |D21.5      |K28.3
R_RDYp      |D10.2      |D10.2      |D21.4      |K28.3
SOFp        |D23.1      |D23.1      |D21.5      |K28.3
SYNCp       |D21.5      |D21.5      |D21.4      |K28.3
WTRMP       |D24.2      |D24.2      |D21.5      |K28.3
X_RDYp      |D23.2      |D23.2      |D21.5      |K28.3


# 9.5 CRC和扰码

## 9.5.1 FIS数据扰码和重复原语的关系

## 9.5.2 扰码和CRC的关系

## 9.5.3 扰码禁用


# 9.6 连接层状态机

## 9.6.1 连接层使用到的术语

1. LRESET：连接层COMRESET或者COMINIT信号
2. PHYRDYn：