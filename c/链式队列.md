 ```c
 #ifndef SQUEUE_H
#define SQUEUE_H

// 链式队列

#include <stdio.h>
#include <stdbool.h>
#include <malloc.h>

typedef struct _PosSingleData
{
    int zero_pos[3];
    int zero_value[3];
    int target_pos[10];
    int target_value[10];
}PosSingleData;

typedef struct _PosFrameData
{
    unsigned int count;     // 周期计数
    int algo_type;          // 算法类型
    float motor_speed;      // 电机速度
    int motor_angle;        // 电机角度
    int channal_num;        // 通道数
    int reverse;
    PosSingleData pos;      // 位置值和峰值点
}PosFrameData;


//typedef PosFrameData QElemType;
typedef int QElemType;

typedef struct QNode
{
    QElemType data;
    struct QNode *next;
}QNode, *QueuePtr;

typedef struct          /* 队列的链表结构 */
{
    QueuePtr front, rear; /* 队头、队尾指针 */
} LinkQueue;

bool InitQueue(LinkQueue *Q);

bool QueueEmpty(LinkQueue Q);

// 入队
bool EnQueue(LinkQueue *Q, QElemType e);

// 出队
bool DeQueue(LinkQueue *Q, QElemType *e);

int QueueLength(LinkQueue Q);

#endif // 
```

```c
#include "squeue.h"

bool InitQueue(LinkQueue *Q)
{
    Q->front = Q->rear = (QueuePtr)malloc(sizeof(QNode));

    if (!Q->front)
        return false;
    Q->front->next = NULL;
        return true;
}
bool EnQueue(LinkQueue *Q, QElemType e)
{
    QueuePtr s = (QueuePtr)malloc(sizeof(QNode));
    if (!s) /* 存储分配失败 */
        return false;
    s->data = e;
    s->next = NULL;
    Q->rear->next = s;  /* 把拥有元素e的新结点s赋值给原队尾结点的后继，见图中① */
    Q->rear = s;       /* 把当前的s设置为队尾结点，rear指向s，见图中② */
    return true;
}

bool DeQueue(LinkQueue *Q, QElemType *e)
{
    QueuePtr p;
    if (Q->front == Q->rear)
        return false;
    p = Q->front->next;     /* 将欲删除的队头结点暂存给p */
    *e = p->data;              /* 将欲删除的队头结点的值赋值给e */
    Q->front->next = p->next;/* 将原队头结点的后继p->next赋值给头结点后继 */
    if (Q->rear == p)       /* 若队头就是队尾，则删除后将rear指向头结点 */
        Q->rear = Q->front;
    free(p);
    return true;
}

int QueueLength(LinkQueue Q)
{
    int i = 0;
    QueuePtr p;
    p = Q.front;
    while (Q.rear != p)
    {
        i++;
        p = p->next;
    }
    return i;
}

bool QueueEmpty(LinkQueue Q)
{
    if (Q.front == Q.rear)
        return true;
    else
        return false;
}
```


```c
#include <stdio.h>
#include "squeue.h"

int main(void)
{
    LinkQueue q;
    InitQueue(&q);
    int i;
    if (QueueEmpty(q))
        printf("queue is empty\n");
    else
        printf("queue is not empty\n");
    EnQueue(&q, 20);
    printf("queue length is %d\n", QueueLength(q));
    EnQueue(&q, 30);
    printf("queue length is %d\n", QueueLength(q));
    EnQueue(&q, 40);
    printf("queue length is %d\n", QueueLength(q));
    EnQueue(&q, 50);
    printf("queue length is %d\n", QueueLength(q));

    if (QueueEmpty(q))
        printf("queue is empty\n");
    else
        printf("queue is not empty\n");

    DeQueue(&q, &i);
    printf("output data is %d\n", i);
    printf("queue length is %d\n", QueueLength(q));
    DeQueue(&q, &i);
    printf("output data is %d\n", i);
    printf("queue length is %d\n", QueueLength(q));
}
```